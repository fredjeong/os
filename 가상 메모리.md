# 14. 가상 메모리

## 14.1 연속 메모리 할당

- 연속 메모리 할당
    - 프로세스에 연속적인 메모리 공간을 할당하는 방식

### 스와핑 (Swapping)

- 대기 상태 또는 오랫동안 사용되지 않은 프로세스들을 임시로 보조기억장치로 보내고, 이렇게 생긴 메모리 상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식
- 스왑 영역(swap space)
    - 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
    - 스왑 아웃(swap-out)
        - 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
    - 스왑 인(swap-in)
        - 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
- 스와핑을 통해서 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있음

### 메모리 할당

#### 최초 적합(first fit)

- 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
- 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 빠른 할당이 가능

#### 최적 적합(best fit)

- 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식

#### 최악 적합(worst fit)

- 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

### 외부 단편화 (External Fragmentation)

- 프로세스들이 메모리에 연속적으로 할당될 때, 메모리 내에 파편화된 공간들이 생겨 큰 프로세스를 적재하기 어려운 상황을 초래, 메모리 낭비가 발생하는 현상
- 메모리 압축(compaction, 조각 모음)
    - 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 여러 개의 작은 빈 공간을 하나의 큰 빈 공간으로 만들 수 있음
    - 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기함
- 메모리 압축의 대안으로 페이징 기법이 등장함

## 14.2 페이징을 통한 가상 메모리 관리

- 가상 메모리(virtual memory)
    - 실행하고자 하는 프로그램의 일부만 메모리에 적 재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술

### 페이징이란

- 외부 단편화가 발생하는 이유는 다른 크기의 프로세스들이 메모리에 연속적으로 할당되었기 때문
- 메모리와 프로세스를 일정한 단위로 잘라, 이를 메모리에 불연속적으로도 할당할 수 있다면 외부 단편화는 발생하지 않음
- 페이징
    1. 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 분할
    2. 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 분할
    3. 페이지를 프레임에 할당
- 페이징 시스템에서도 스와핑을 사용할 수 있음
    - 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
    - 실행에 필요한 페이지들은 메모리로 스왑 인
- 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요는 없음

### 페이지 테이블

- 프로세스가 메모리에 불연속적으로 배치되면 CPU는 다음에 실행할 명령어의 위치를 찾기 어려움
- 페이징 시스템은 프로세스가 실제 메모리 내의 주소인 물리 주소에 불연속적으로 배치되더라도 CPU가 바라보는 주소인 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용함
    - 현재 어떤 페이지가 어떤 프레임에 할당되었는지에 대한 정보
    - 페이지 테이블을 통해서 CPU는 페이지 번호만 보고도 해당 페이지가 적재된 프레임을 찾을 수 있음
- 프로세스마다 각자의 페이지 테이블을 가지고 있음
- 각 프로세스의 페이지 테이블들은 메모리에 적재됨
- CPU 내의 **페이지 테이블 베이스 레지스터(PTBR;Page Table Base Register)**는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴
- 하지만 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어나는 문제가 있음
- 따라서 일반적으로 CPU 곁에 TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 두어 페이지 테이블의 일부 내용을 저장
    - TLB 히트 
        - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
        - 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없으므로 메모리 접근을 한 번만 하면 됨
    - TLB 미스
        - 페이지 번호가 TLB에 없을 경우 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근해야 함

### 페이징에서의 주소 변환

- 특정 주소에 접근하기 위해 필요한 정보
    - 어떤 페이지 혹은 프레임에 접근하고 싶은지
    - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호(page number)와 변위(offset)로 이루어져 있음
    - 페이지 번호
        - 접근하고자 하는 페이지의 번호
        - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지 알 수 있음
    - 변위
        - 접근하려는 주소가 프레임의 시작 주소로부터 얼만큼 떨어져 있는지를 알기 위한 정보
    - 논리 주소 (페이지 번호, 변위)는 페이지 테이블을 통해 물리 주소 (프레임 번호, 변위)로 변환됨

### 페이지 테이블 엔트리

- 페이지 테이블의 각각의 행
- 페이지 테이블 엔트리가 포함하는 추가 정보
    - 유효 비트(valid bit)
        - 현재 해당 페이지에 접근 가능한지 여부를 나타냄
        - 페이지가 메모리에 적재되어 있다면 1, 그렇지 않다면 0
        - CPU가 유효 비트 값 0인 페이지로 접근하려고 하면 페이지 폴트(page fault)라는 예외 발생
            - CPU는 기존의 작업 내용 백업
            - 페이지 폴트 처리 루틴 실행
            - 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
            - 페이지 폴트를 처리했으므로 CPU가 해당 페이지에 접근 가능
    - 보호 비트(protection bit)
        - 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 읽기만 가능한 페이지인지 나타냄
        - 읽기 전용 페이지에 쓰기를 시도할 경우 운영체제가 이를 막음
    - 참조 비트(reference bit)
        - CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄
        - 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트 값이 1로 변경됨
    - 수정 비트(modified bit) 또는 더티 비트(dirty bit)
        - 해당 페이지에 데이터를 쓴 적이 있는지 수정 여부를 나타냄
        - 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재

## 14.3 페이지 교체와 프레임 할당

### 요구 페이징 (Demand Paging)

- 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
- 과정
    - CPU가 특정 페이지에 접근하는 명령어를 실행
    - 해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근
    - 해당 페이지가 현재 메모리에 없을 경우 (유효 비트가 0일 경우) 페이지 폴트 발생
    - 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
- 요구 사항
    - 페이지 교체
    - 프레임 할당

### 페이지 교체 알고리즘

- 요구 페이징 기법으로 페이지를 적재하면 메모리가 가득 차게 되는데, 이 때, 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 함
- 페이지 교체 알고리즘이 내보낼 페이지를 결정
- 페이지 폴트를 적게 일으키는 알고리즘이 좋은 알고리즘이라고 할 수 있음
    - 페이지 폴트 횟수는 CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열인 페이지 참조열(page reference string)을 통해 알 수 있음

#### FIFO(First-In-First-Out) 페이지 교체 알고리즘

- 메모리에 가장 먼저 올라온 페이지부터 내보내는 방식

#### 최적 페이지 교체 알고리즘 (optimal page replacement algorithm)

- CPU에 의해 참조되는 횟수를 고려하여, 사용 빈도가 가장 낮은 페이지를 교체하는 방식
- 가장 낮은 페이지 폴트율을 보장
- 실제 구현이 매우 어려움
- 그 자체를 사용하기보다는 다른 페이지 교체 알고리즘의 이론 상 성능을 평가하기 위한 목적으로 사용됨

#### LRU(Least Recently Used) 페이지 교체 알고리즘

- 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식

### 스래싱과 프레임 할당

- 프로세스가 사용할 수 있는 프레임 수가 많으면 일반적으로 페이지 폴트 빈도는 감소함
- 스래싱(thrashing)
    - 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
- 동시에 실행되는 프로세스 수가 필요 이상으로 늘어나면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생하고, 이에 따라 CPU 이용률이 떨어져 전체적인 성능이 저해됨
- 따라서 운영체제는 각 프로세스들이 무리 없이 실행되기 위한 최소한의 프레임 수를 파악하여 프로세스들에 적절한 수만큼 프레임을 할당해줄 수 있어야 함
- 균등 할당(equal allocation)
    - 모든 프로세스에 균등하게 프레임을 제공하는 방식
    - 실행되는 프로세스들의 크기가 각기 다르므로 비효율적
- 비례 할당(proportional allocation)
    - 프로세스의 크기가 크면 프레임을 많이 할당하고, 프로세스 크기가 작으면 프레임을 적게 나눠주는 방식
- 작업 집합 모델(working set model)
    - 작업 집합(working set)
        - 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합  
    - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억
    - CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당
    - CPU가 과거에 주로 참조한 페이지를 작업 집합에 포함한다면 운영체제는 작업 집합의 크기만큼만 프레임을 할당
- 페이지 폴트 빈도(PFF; Page-Fault Frequency)
    - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있고, 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있다고 생각할 수 있음
    - 페이지 폴트율에 상한선과 하한선을 정하고, 해당 범위 내에서 프레임을 할당하는 방식