# 3. 명령어

## 3.1 소스 코드와 명령어

### 고급 언어와 저급 언어

- 고급 언어(high-level programming langauge): 사람을 위한 언어
- 저급 언어(low-level programming language): 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어인 명령어로 변환되어야 함

#### 저급 언어

- 기계어(machine code)
    - 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어(assembly language)
    - 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

### 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환되는 방식에는 컴파일(compile) 방식과 인터프리트(interpret) 방식이 있음

#### 컴파일 언어

- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 컴파일러는 개발자가 작성한 소스 코드를 저급 언어로 컴파일하며, 이 때, 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패
- 컴파일이 성공적으로 수행되면 소스 코드는 목적 코드(object code)라는 저급 언어로 변환됨
- 예시: C

#### 인터프리터 언어

- 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
- 인터프리터 언어는 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하므로 소스코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
- 오류가 있는 지점 바로 직전까지는 코드가 올바르게 수행됨
- 일반적으로 인터프리터 언어가 컴파일 언어보다 느림

- 예시: Python

## 3.2 명령어의 구조

### 연산 코드와 오퍼랜드

- 명령어는 연산 코드와 오퍼랜드로 구성됨
    - 연산 코드(operation code, 연산자): 명령어가 수행할 연산
    - 오퍼랜드(operand, 피연산자): 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치

#### 오퍼랜드

- 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터의 주소가 올 수 있음
- 대부분의 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담겨지므로 **주소 필드**라고도 부름

#### 연산 코드

- 기본적인 연산 코드 유형
    - 데이터 전송
    - 산술/논리 연산
    - 제어 흐름 변경
    - 입출력 제어

### 주소 지정 방식

- 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 3-주소 명령어에서는 오퍼랜드 필드당 4비트가 주어짐
    - 이 경우 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 $2^4$개로 제한됨
    - 하지만 오퍼랜드 필드 안에 메모리 주소가 담긴다면, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커짐
    - 예를 들어, 한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정하면, 표현할 수 있는 정보의 가짓수는 $2^16$으로 증가함
- 유효 주소(effective address): 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식(addressing mode): 유효 주소를 찾는 방법

#### 즉시 주소 지정 방식(immediate addressing mode)

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 표현할 수 있는 데이터의 크기가 작지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 빠르다는 장점이 있음

#### 직접 주소 지정 방식 (direct addressing mode)

- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼으로 제한됨

#### 간접 주소 지정 방식 (indirect addressing mode)

- 유효 주소의 주소를 오퍼랜드 필드에 명시
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌지만, 두 번의 메모리 접근이 필요하므로 상대적으로 느림

#### 레지스터 주소 지정 방식 (register addressing mode)

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- CPU 외부에 있는 메모리보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름
- 표현할 수 있는 레지스터 크기에 제한이 생김

#### 레지스터 간접 주소 지정 방식 (register indirect addressing mode)

- 연산에 사용할 데이터를 메모리에 저장하고, 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
- 메모리에 접근하는 횟수가 한 번으로 줄어들어 간접 주소 지정 방식보다 빠름