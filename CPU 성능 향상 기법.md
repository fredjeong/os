# 5. CPU 성능 향상 기법

## 5.1 빠른 CPU를 위한 설계 기법

### 클럭

- 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복하고, 다른 부품들도 그에 발맞춰 더 빠르게 작동함
- 따라서 클럭 속도가 높은 CPU는 일반적으로 성능이 좋음
- 클럭 속도는 1초에 클럭이 몇 번 반복되는지를 나타내는 Hz 단위로 측정함
- 하지만 클럭 속도를 무리하게 높이면 발열 문제가 심각해짐
- 따라서 클럭 속도만으로 CPU의 성능을 올리는 것에는 한계가 있음

### 코어와 멀티코어

- 전통적인 CPU는 ALU, 제어장치, 레지스터로 구성됨
- 이러한 부품 단위 하나를 **코어**라고 부름
- 코어를 여러 개 포함하고 있는 CPU를 멀티코어 CPU 또는 멀티코어 프로세서라고 함
- 멀티코어의 처리 속도가 단일코어보다 더 빠름
- 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않음
- 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없음

### 스레드와 멀티스레드

- 스레드(thread)
    - 실행 흐름의 단위
    - CPU에서 사용되는 **하드웨어적 스레드**와 프로그램에서 사용되는 **소프트웨어적 스레드**로 나뉨

#### 하드웨어적 스레드 (하드웨어 스레드)

- **하드웨어적 스레드의 정의: 하나의 코어가 동시에 처리하는 명령어 단위**
- 이전의 CPU는 1코어 1스레드 CPU
    - 명령어를 실행하는 부품이 하나 있고, 한 번에 하나씩 명령어를 실행하는 CPU
- 멀티스레드 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있음
    - 예시: 2코어 4스레드 CPU는 명령어를 실행하는 부품을 두 개 포함하고, 한 번에 네 개의 명령어를 처리할 수 있는 CPU를 의미
    - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서 또는 멀티스레드 CPU라고 함
- 논리 프로세서(logical processor)로 불리기도 함

#### 소프트웨어적 스레드 (스레드)

- **소프트웨어적 스레드의 정의: 하나의 프로그램에서 독립적으로 실행되는 단위**
- 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있음
- 예시
    - 워드 프로세서 프로그램에서 요구사항으로 사용자로부터 입력받은 내용을 화면에 보여주는 기능, 사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능, 사용자가 입력한 내용을 수시로 저장하는 기능이 있을 때, 기능들을 작동시키는 코드를 각각의 스레드로 만들면 동시에 실행할 수 있음

#### 멀티스레드 프로세서

- 멀티스레드 프로세서의 핵심은 레지스터임
- 하나의 코어로 여러 명령어를 동시에 처리하도록 만들기 위해서는 명령어 하나를 처리하기 위해 꼭 필요한 레지스터를 여러 개 만들면 됨
    - 프로그램 카운터가 두 개 있다면 메모리에서 가져올 명령어 주소를 두 개 지정할 수 있음
    - 스택 포인터가 두 개 있다면 두 개의 스택을 관리할 수 있음

## 5.2 명령어 병렬 처리 기법 (ILP; Instruction-Level Parallelism)

### 명령어 파이프라인

- 명령어 처리 과정은 다음과 같이 나눌 수 있음
    - 명령어 인출 (Fetch Instruction)
    - 명령어 해석 (Decode Instruction)
    - 명령어 실행 (Execute Instruction)
    - 결과 저장 (Write Back)
- 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있음
- 따라서 명령어 파이프라인에 명령어들을 넣고 동시에 처리할 수 있음
- 파이프라이닝이 높은 성능을 가져오지만, 특정 상황에서 성능 향상에 실패하는 경우도 있음 (파이프라인 위험, pipeline hazard)
    - 데이터 위험 (data hazard)
    - 제어 위험 (control hazard)
    - 구조적 위험 (structural hazard)

#### 데이터 위험

- 명령어 간 데이터 의존성에 의해 발생
- 데이터 의존적인 두 명령어를 동시에 실행하면 파이프라인이 제대로 작동하지 않음 

#### 제어 위험

- 주로 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
- 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신되지만, 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들이 실행되지 않음
- 이를 막기 위해 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 분기 예측(branch prediction) 기술이 사용됨

#### 구조적 위험

- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려 할 때 발생
- 자원 위험(resource hazard)이라고도 부름

### 슈퍼스칼라

- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 함
- 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 파이프라인 위험 등의 예상치 못한 문제로 실제로는 반드시 파이프라인 개수에 비례하여 빨라지지는 않음
- 따라서 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함

### 비순차적 명령어 처리 (OoOE; Out-of-Order Execution)

- 모든 명령어를 순차적으로만 처리한다면 예상치 못한 상황에서 명령어 파이프라인이 멈추게 됨
- 데이터 의존성이 전혀 없는, 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리 기법이라고 함

## 5.3 CISC와 RISC

### 명령어 집합

- CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합(instruction set) 또는 명령어 집합 구조(ISA; Instruction Set Architecture)라고 함
- CPU마다 ISA가 조금씩 다르고, ISA가 다른 CPU끼리는 서로의 명령어를 이해하지 못함
- ISA마다 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등이 달라지므로, 하드웨어 설계에도 영향을 미침

### CISC (Complex Instruction Set Computer)

- 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식
- 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용함
- 메모리에 접근하는 주소 지정 방식도 다양함
- 장점
    - 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있음
- 단점
    - 활용하는 명령어가 복잡하고 다양한 기능을 제공하므로 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
    - 복잡한 명령어로 인해 명령어 하나를 실행하는 데 여러 클럭 주기를 필요로 함
    - 따라서 명령어 파이프라인을 구현하는 데 어려움이 있음

### RISC (Reduced Instruction Set Computer)

- 명령어의 종류가 적고, 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향함 (**고정 길이 명령어**)
- 메모리 접근을 단순화하고 최소화를 추구하여 주소 지정 방식의 종류가 적음
- 메모리 접근을 최소화한 대신 레지스터를 적극적으로 활용하여 레지스터를 이용하는 연산이 많고, 범용 레지스터 개수가 많음
- 장점
    - 명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되므로 명령어 파이프라이닝에 최적화됨
- 단점
    - 사용 가능한 명령어 개수가 CISC보다 적어 더 많은 명령으로 프로그램을 작동시킴
    
    