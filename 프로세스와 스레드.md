# 10. 프로세스와 스레드

## 10.1 프로세스 개요

### 프로세스 직접 확인하기

- 포그라운드 프로세스(foreground process)
    - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- 백그라운드 프로세스(background process)
    - 사용자가 볼 수 없는 공간에서 실행되는 프로세스
- 데몬(daemon) 또는 서비스(service)
    - 사용자와 상호작용하지 않고 정해진 태스크를 수행하는 백그라운드 프로세스

### 프로세스 제어 블록

- 모든 프로세스는 실행을 위해 CPU를 필요로 하지만, CPU 자원은 한정되어 있음
- 따라서 프로세스들은 차례대로 돌아가며 한정된 시간 동안 CPU를 이용함
- 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 시간이 끝났음을 알리는 타이머 인터럽트(타임아웃 인터럽트)가 발생하면 다음 차례가 올 때까지 기다림
- 운영체제는 프로세스의 실행 순서를 관리하고 자원을 배분하기 위해 프로세스 제어 블록(PCB; Process Control Block)을 이용
    - PCB에는 해당 프로세스를 식별하기 위해 필수적인 정보들이 저장됨
        - 프로세스 ID(PID; Process ID)
            - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
        - 레지스터 값
            - 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값
        - 프로세스 상태
            - 현재 프로세스가 입출력장치를 사용하기 위해 기다리고 있는 상태인지, CPU를 사용하기 위해 기다리고 있는 상태인지, CPU를 이용하고 있는 상태인지 등에 대한 정보
        - CPU 스케줄링 정보
            - 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
        - 메모리 관리 정보
            - 프로세스가 메모리의 어느 주소에 저장되어 있는지에 대한 정보
        - 사용한 파일과 입출력장치 목록
            -어떤 입출력장치가 프로세스에 할당되었는지, 프로세스가 어떤 파일들을 열었는지에 대한 정보
    - PCB는 프로세스 생성 시 커널 영역에 만들어지고 프로세스 실행이 끝나면 폐기됨

### 문맥 교환

- 문맥(context)
    - 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보
    - 하나의 프프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있음
- 문맥 교환(context switching)
    - 인터럽트가 발생했을 때 운영체제가 기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
    - 문맥 교환이 자주 일어나면 프로세스가 그만큼 빨리 번갈아 가며 수행되기 때문에 프로세스들이 동시에 실행되는 것처럼 보임
    - 문맥 교환이 지나치게 잦으면 오버헤드가 발생할 수 있기 때문에 문맥 교환의 빈도가 높다고 반드시 좋은 것은 아님

### 프로세스의 메모리 영역

#### 코드 영역(code segment, text segment)

- 정적 할당 영역
- 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장됨
- CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지된 읽기 전용(read-only) 공간

#### 데이터 영역(data segment)

- 정적 할당 영역
- 프로그램이 실행되는 동안 유지되어야 할 데이터가 저장되는 공간
- 예시: 전역 변수

#### 힙 영역(heap segment)

- 동적 할당 영역
- 사용자가 직접 할당할 수 있는 저장 공간
- 프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했다면 후에 해당 공간을 반환해야 함
- 메모리 누수(memory leak)
    - 메모리 공간을 반환하지 않는다면 할당한 공간은 메모리 내에 계속 남아 메모리 낭비를 초래함

#### 스택 영역(stack segment)

- 동적 할당 영역
- 데이터를 일시적으로 저장하는 공간
- 예시: 지역 변수

## 10.2 프로세스 상태와 계층 구조

### 프로세스 상태

- 하나의 프로세스는 여러 상태를 거치며 실행됨
- 운영체제는 프로세스의 상태를 PCB를 통해 인식하고 관리함

#### 생성 상태(new)

- 프로세스를 생성 중인 상태
- 프로세스가 이제 막 메모리에 적재되어 PCB를 할당받은 상태
- 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU의 할당을 기다림

#### 준비 상태(ready)

- 프로세스가 CPU를 할당받을 차례가 되지 않아 기다리고 있는 상태
- 준비 상태 프로세스는 차례가 되면 CPU를 할당받아 실행 상태가 됨

#### 실행 상태(running)

- CPU를 할당받아 실행 중인 상태
- 프로세스가 할당된 시간을 모두 사용하여 타이머 인터럽트가 발생하면 다시 준비 상태로 돌아감
- 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 됨

#### 대기 상태(blocked)

- 입출력장치의 작업을 기다리는 상태
    - 입출력 작업은 CPU에 비해 처리 속도가 느리므로 입출력 작업을 요청한 프로세스는 입출력장치가 입출력을 끝내 입출력 완료 인터럽트를 받을 때까지 기다려야 함
- 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다림

#### 종료 상태(terminated)

- 프로세스가 종료된 상태
- 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리

### 프로세스 계층 구조

- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음
    - 부모 프로세스(parent process)
        - 새 프로세스를 생성한 프로세스
    - 자식 프로세스(child process)
        - 부모 프로세스에 의해 생성된 프로세스
        - 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID(Parent PID)가 기록되기도 함
- 프로세스 계층 구조
    - 프로세스가 자식 프로세스들을 생성하는 과정을 도표로 그린 것
    
### 프로세스 생성 기법

- 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성함
    - 이 때, 메모리 내의 내용, 열린 파일의 목록 등 부모 프로세스의 자원들이 자식 프로세스에 상속됨
- 만들어진 복사본인 자식 프로세스는 exec을 통해 자신의 메모리 공간을 다른 프로그램으로 교체함

## 10.3 스레드

- 스레드(thread)
    - 실행의 단위
    - 프로세스를 구성하는 실행의 흐름 단위
- 하나의 프로세스는 여러 개의 스레드를 가질 수 있음
- 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있음

### 프로세스와 스레드

- 단일 스레드 프로세스
    - 하나의 실행 흐름을 가지고 한 번에 하나의 부분만 실행되는 프로세스
- 스레드 개념의 도입으로 하나의 프로세스가 한 번에 여러 일을 동시에 처리할 수 있게 됨
- 따라서 스레드는 프로세스를 구성하는 실행 단위로 볼 수 있음
- 프로세스의 스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 **프로세스 자원을 공유하며** 실행됨

### 멀티프로세스와 멀티스레드

- 멀티프로세스(multiprocess)
    - 여러 프로세스를 동시에 실행하는 것
- 멀티스레드 (multithread)
    - 여러 스레드로 프로세스를 동시에 실행하는 것
- 멀티스레드 프로세스는 여러 프로세스를 병행 실행하는 것보다 메모리를 더 효율적으로 사용할 수 있음
- 스레드는 프로세스의 자원을 공유하기 때문에 서로 협력과 통신에 유리함
- 멀티프로세스 환경에서는 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 적거나 없지만, 멀티스레드 환경에서는 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음